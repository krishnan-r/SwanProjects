# Copyright (c) SWAN Development Team.
# Author: Omar.Zapata@cern.ch 2021

from notebook.base.handlers import APIHandler
from notebook.utils import url_path_join

import tornado
from tornado.web import StaticFileHandler
from swanprojects.utils import get_software_stacks
import os
import json
import shutil

from swanprojects.utils import project_path, get_project_info, get_project_readme, get_user_script_content

import subprocess


class ProjectInfoHandler(APIHandler):
    @tornado.web.authenticated
    def post(self):
        """
        Post request for the SwanLauncher/SwanFileBrowser,
        this endpoint returns project information such as stack, release, platform etc..
        if the path is not inside the project return and empty project data.

        At th same time this endpoint allows to set the kernel spec manager path,
        to load and unload the kernels according to the project information.
        """
        input_data = self.get_json_body()
        path = input_data["path"]
        project = project_path(path)
        self.kernel_spec_manager.set_path(path)
        project_data = {}
        if project is not None:
            project_data = get_project_info(project)

            project_data["name"] = project.split(os.path.sep)[-1]
            readme = get_project_readme(project)
            if readme is not None:
                project_data["readme"] = readme
            project_data["user_script"] = get_user_script_content(project)
        payload = {"project_data": project_data}
        self.finish(json.dumps(payload))


class StacksInfoHandler(APIHandler):
    @tornado.web.authenticated
    def get(self):
        """
        This endpoint is required for the project dialog, it's returning the information save on stacks.json
        """
        self.finish(json.dumps({"stacks": get_software_stacks()}))
        pass


class CreateProjectHandler(APIHandler):
    @tornado.web.authenticated
    def post(self):
        """
        Endpoint to create a project, receive project information such as name, stack, platform, release, user_script.
        The project is created at $HOME/SWAN_projects/project_name and a hidden json ".swanproject" file with the information
        project is set inside the project folder.
        """
        input_data = self.get_json_body()
        name = input_data["name"]
        stack = input_data["stack"]  # CMSSW/LCG
        platform = input_data["platform"]  # SCRAM
        release = input_data["release"]  # CMSSW
        user_script = input_data["user_script"]

        project_dir = os.environ["HOME"] + "/SWAN_projects/" + name
        os.makedirs(project_dir)
        swan_project_file = project_dir + os.path.sep + '.swanproject'
        swan_project_content = {'stack': stack, 'release': release,
                                'platform': platform}

        with open(swan_project_file, 'w+') as f:
            f.write(json.dumps(swan_project_content, indent=4, sort_keys=True))
            f.close()

        swan_user_script_file = project_dir + os.path.sep + '.userscript'
        with open(swan_user_script_file, 'w') as f:
            f.write(user_script)
            f.close()

        command = ["swan_kmspecs", "--project_name", name]
        proc = subprocess.Popen(command, stdout=subprocess.PIPE)
        proc.wait()
        data = proc.stdout.read().decode("utf-8")
        proc.communicate()

        data = {"project_dir": "SWAN_projects/" + name,
                "msg": "created project: {}".format(name)}
        self.finish(json.dumps(data))


class EditProjectHandler(APIHandler):

    @tornado.web.authenticated
    def post(self):
        """
        This endpoint allows to edit project information, such as name, stack, platform etc..
        The project can be renamed from $HOME/SWAN_projects/old_name to $HOME/SWAN_projects/name
        and metadata in the .swanproject is updated.
        """
        input_data = self.get_json_body()
        old_name = input_data["old_name"]
        name = input_data["name"]
        stack = input_data["stack"]  # CMSSW/LCG
        platform = input_data["platform"]  # SCRAM
        release = input_data["release"]  # CMSSW
        user_script = input_data["user_script"]

        project_dir = os.environ["HOME"] + "/SWAN_projects/" + name
        if old_name != name:
            old_project_dir = os.environ["HOME"] + "/SWAN_projects/" + old_name
            os.rename(old_project_dir, project_dir)

        swan_project_file = project_dir + os.path.sep + '.swanproject'
        swan_project_content = {'stack': stack, 'release': release,
                                'platform': platform}
        kernel_dir = project_dir + "/.local/share/jupyter/kernels"

        # removing old native kernels for python only(this is generated by us)
        if os.path.exists(kernel_dir + "/python2"):
            shutil.rmtree(kernel_dir + "/python2")

        if os.path.exists(kernel_dir + "/python3"):
            shutil.rmtree(kernel_dir + "/python3")

        with open(swan_project_file, 'w+') as f:
            f.write(json.dumps(swan_project_content, indent=4, sort_keys=True))
            f.close()

        swan_user_script_file = project_dir + os.path.sep + '.userscript'
        with open(swan_user_script_file, 'w') as f:
            f.write(user_script)
            f.close()

        command = ["swan_kmspecs", "--project_name", name]
        print(" ".join(command))
        proc = subprocess.Popen(command, stdout=subprocess.PIPE)
        proc.wait()
        output = proc.stdout.read().decode("utf-8")
        print(output)
        proc.communicate()

        data = {"project_dir": "SWAN_projects/" + name,
                "msg": "edited project: {}".format(name)}
        self.finish(json.dumps(data))


# URL to handler mappings
def setup_handlers(web_app, url_path):
    host_pattern = ".*$"
    base_url = web_app.settings["base_url"]

    # Prepend the base_url so that it works in a jupyterhub setting
    create_pattern = url_path_join(base_url, url_path, "project/create")
    edit_pattern = url_path_join(base_url, url_path, "project/edit")
    project_pattern = url_path_join(base_url, url_path, "project/info")
    kernel_pattern = url_path_join(base_url, url_path, "stacks/info")
    handlers = [(create_pattern, CreateProjectHandler)]
    handlers.append((edit_pattern, EditProjectHandler))
    handlers.append((project_pattern, ProjectInfoHandler))
    handlers.append((kernel_pattern, StacksInfoHandler))

    web_app.add_handlers(host_pattern, handlers)

    # Prepend the base_url so that it works in a jupyterhub setting
    doc_url = url_path_join(base_url, url_path, "static")
    doc_dir = os.getenv(
        "SWAN_JLAB_SERVER_STATIC_DIR",
        os.path.join(os.path.dirname(__file__), "static"),
    )
    handlers = [("{}/(.*)".format(doc_url),
                 StaticFileHandler, {"path": doc_dir})]
    web_app.add_handlers(".*$", handlers)
